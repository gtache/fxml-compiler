package com.github.gtache.fxml.compiler.parsing.listener;

import java.util.Map;
import java.util.ResourceBundle;
import java.util.HashMap;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import javafx.event.Event;
import java.lang.reflect.Method;


/**
 * Generated code, not thread-safe
 */
public final class IncludesController {

    private final Map<Class<?>, Object> controllersMap;
    private final Map<Class<?>, ResourceBundle> resourceBundlesMap;
    private boolean loaded;
    private com.github.gtache.fxml.compiler.parsing.listener.IncludesController controller;

    /**
     * Instantiates a new IncludesController with no nested controllers and no resource bundle
     * @param controller The controller
     */
    public IncludesController(final com.github.gtache.fxml.compiler.parsing.listener.IncludesController controller) {
        this(Map.of(com.github.gtache.fxml.compiler.parsing.listener.IncludesController.class, controller), Map.of());
    }

    /**
     * Instantiates a new IncludesController with no nested controllers
     * @param controller The controller
     * @param resourceBundle The resource bundle
     */
    public IncludesController(final com.github.gtache.fxml.compiler.parsing.listener.IncludesController controller, final ResourceBundle resourceBundle) {
        this(Map.of(com.github.gtache.fxml.compiler.parsing.listener.IncludesController.class, controller), Map.of(com.github.gtache.fxml.compiler.parsing.listener.IncludesController.class, resourceBundle));
    }

    /**
     * Instantiates a new IncludesController with nested controllers
     * @param controllersMap The map of controller class to controller
     * @param resourceBundlesMap The map of controller class to resource bundle
     */
    public IncludesController(final Map<Class<?>, Object> controllersMap, final Map<Class<?>, ResourceBundle> resourceBundlesMap) {
        this.controllersMap = Map.copyOf(controllersMap);
        this.resourceBundlesMap = Map.copyOf(resourceBundlesMap);
    }

    public javafx.scene.Parent load() {
    if (loaded) {
        throw new IllegalStateException("Already loaded");
    }
    final var bundle = resourceBundlesMap.get(com.github.gtache.fxml.compiler.parsing.listener.IncludesController.class);
    controller = (com.github.gtache.fxml.compiler.parsing.listener.IncludesController) controllersMap.get(com.github.gtache.fxml.compiler.parsing.listener.IncludesController.class);
    final var object0 = new javafx.scene.layout.BorderPane();
    final var object1 = new javafx.scene.layout.VBox();
    javafx.scene.layout.BorderPane.setAlignment(object1, javafx.geometry.Pos.CENTER);
    final var object2 = new javafx.scene.layout.HBox();
    object2.setAlignment(javafx.geometry.Pos.CENTER);
    object2.setSpacing(10.0);
    final var object3 = new javafx.scene.control.Slider();
    controller.playSlider = object3;
    javafx.scene.layout.HBox.setHgrow(object3, javafx.scene.layout.Priority.ALWAYS);
    final var object4 = new javafx.geometry.Insets(0, 0, 0, 10.0);
    object3.setPadding(object4);
    final var object5 = new javafx.scene.control.Label();
    controller.playLabel = object5;
    object5.setText("Label");
    final var object6 = new javafx.geometry.Insets(0, 10.0, 0, 0);
    object5.setPadding(object6);
    object2.getChildren().addAll(object3, object5);
    final var object7 = new javafx.geometry.Insets(10.0, 0, 0, 0);
    object2.setPadding(object7);
    final var object8 = new javafx.scene.layout.HBox();
    object8.setAlignment(javafx.geometry.Pos.CENTER);
    object8.setSpacing(10.0);
    final var object9 = new javafx.scene.control.Button();
    controller.playButton = object9;
    object9.setMnemonicParsing(false);
    object9.setOnAction(e -> callMethod("playPressed", e));
    final var object10 = new javafx.geometry.Insets(0, 20.0, 0, 0);
    javafx.scene.layout.HBox.setMargin(object9, object10);
    final var object11 = new javafx.scene.control.Label();
    object11.setText(bundle.getString("media.volume.label"));
    final var object12 = new javafx.scene.control.Slider();
    controller.volumeSlider = object12;
    object12.setValue(100);
    final var object13 = new javafx.scene.control.Label();
    controller.volumeValueLabel = object13;
    object13.setText("Label");
    final var map0 = new HashMap<>(resourceBundlesMap);
    final var bundle0 = ResourceBundle.getBundle("com.github.gtache.fxml.compiler.parsing.listener.ControlsBundle");
    map0.put(com.github.gtache.fxml.compiler.parsing.listener.ControlsController, bundle0);
    final var view0 = new com.github.gtache.fxml.compiler.parsing.listener.ControlsView(controllersMap, map0);
    final var object14 = view0.load();
    final var controller0 = view0.controller();
    controller.controlsController = controller0;
    object8.getChildren().addAll(object9, object11, object12, object13, object14);
    final var object15 = new javafx.geometry.Insets(10.0, 10.0, 10.0, 10.0);
    object8.setPadding(object15);
    object1.getChildren().addAll(object2, object8);
    object0.setBottom(object1);
    final var object16 = new javafx.scene.layout.VBox();
    controller.vbox = object16;
    final var object17 = new javafx.scene.control.ToolBar();
    controller.toolBar = object17;
    final var object18 = new javafx.scene.control.TitledPane();
    controller.titledPane = object18;
    final var object19 = new javafx.scene.layout.TilePane();
    controller.tilePane = object19;
    final var object20 = new javafx.scene.text.TextFlow();
    controller.textFlow = object20;
    final var object21 = new javafx.scene.control.TabPane();
    controller.tabPane = object21;
    final var object22 = new javafx.scene.control.Tab();
    controller.tab = object22;
    final var object23 = new javafx.scene.layout.StackPane();
    controller.stackPane = object23;
    final var object24 = new javafx.scene.control.SplitPane();
    controller.splitPane = object24;
    final var object25 = new javafx.scene.control.ScrollPane();
    controller.scrollPane = object25;
    final var object26 = new javafx.scene.layout.Pane();
    controller.pane = object26;
    final var object27 = new javafx.scene.layout.HBox();
    controller.hbox = object27;
    final var object28 = new javafx.scene.Group();
    controller.group = object28;
    final var object29 = new javafx.scene.layout.GridPane();
    controller.gridPane = object29;
    final var object30 = new javafx.scene.layout.ColumnConstraints();
    controller.columnConstraints = object30;
    object30.setHgrow(javafx.scene.layout.Priority.SOMETIMES);
    object30.setMinWidth(10.0);
    object29.getColumnConstraints().addAll(object30);
    final var object31 = new javafx.scene.layout.RowConstraints();
    object31.setMinHeight(10.0);
    object31.setVgrow(javafx.scene.layout.Priority.SOMETIMES);
    object29.getRowConstraints().addAll(object31);
    final var object32 = new javafx.scene.layout.FlowPane();
    controller.flowPane = object32;
    final var object33 = new javafx.scene.control.DialogPane();
    controller.dialogPane = object33;
    final var object34 = new javafx.scene.control.ButtonBar();
    controller.buttonBar = object34;
    final var object35 = new javafx.scene.layout.AnchorPane();
    controller.anchorPane = object35;
    final var object36 = new javafx.scene.control.Label();
    object36.setManaged(false);
    object35.getChildren().addAll(object36);
    object34.getButtons().addAll(object35);
    object33.setContent(object34);
    object32.getChildren().addAll(object33);
    object29.getChildren().addAll(object32);
    object28.getChildren().addAll(object29);
    object27.getChildren().addAll(object28);
    object26.getChildren().addAll(object27);
    object25.setContent(object26);
    object24.getItems().addAll(object25);
    object23.getChildren().addAll(object24);
    object22.setContent(object23);
    object21.getTabs().addAll(object22);
    object20.getChildren().addAll(object21);
    object19.getChildren().addAll(object20);
    object18.setContent(object19);
    object17.getItems().addAll(object18);
    object16.getChildren().addAll(object17);
    object0.setCenter(object16);
    try {
        final var initialize = controller.getClass().getDeclaredMethod("initialize");
        initialize.setAccessible(true);
        initialize.invoke(controller);
    } catch (final InvocationTargetException | IllegalAccessException e) {
        throw new RuntimeException("Error using reflection", e);
    } catch (final NoSuchMethodException ignored) {
    }
    loaded = true;
    return object0;
}

    private <T extends Event> void callMethod(final String methodName, final T event) {
    try {
        final Method method;
        final var methods = Arrays.stream(controller.getClass().getDeclaredMethods())
                .filter(m -> m.getName().equals(methodName)).toList();
        if (methods.size() > 1) {
            final var eventMethods = methods.stream().filter(m ->
                    m.getParameterCount() == 1 && Event.class.isAssignableFrom(m.getParameterTypes()[0])).toList();
            if (eventMethods.size() == 1) {
                method = eventMethods.getFirst();
            } else {
                final var emptyMethods = methods.stream().filter(m -> m.getParameterCount() == 0).toList();
                if (emptyMethods.size() == 1) {
                    method = emptyMethods.getFirst();
                } else {
                    throw new IllegalArgumentException("Multiple matching methods for " + methodName);
                }
            }
        } else if (methods.size() == 1) {
            method = methods.getFirst();
        } else {
            throw new IllegalArgumentException("No matching method for " + methodName);
        }
        method.setAccessible(true);
        if (method.getParameterCount() == 0) {
            method.invoke(controller);
        } else {
            method.invoke(controller, event);
        }
    } catch (final IllegalAccessException | InvocationTargetException ex) {
        throw new RuntimeException("Error using reflection on " + methodName, ex);
    }
}


    /**
     * @return The controller
     */
    public com.github.gtache.fxml.compiler.parsing.listener.IncludesController controller() {
        if (loaded) {
            return controller;
        } else {
            throw new IllegalStateException("Not loaded");
        }
    }
}
